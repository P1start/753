use std::fmt;

#[derive(Debug, Clone)]
pub struct VariableInfo {
    /// Indicates whether or not the variable is mutable.
    /// 
    /// For example, all temporary variables are immutable.
    pub mutable: bool,
}

#[derive(Debug, Clone)]
pub struct BasicBlock {
    pub phi: Option<VarId>,
    pub instructions: Vec<Instruction>,
    pub terminator: Terminator,
}

impl fmt::Display for BasicBlock {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "(do")?;
        for instruction in &self.instructions {
            writeln!(f, "    {}", instruction)?;
        }
        write!(f, "    {}", self.terminator)?;
        write!(f, ")")
    }
}

/// The unique identifier for a variable within this function, including temporary variables.
/// 
/// For local variables with names, this coincides with the identifier generated by resolve.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct VarId(pub u32);

impl fmt::Display for VarId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "var{}", self.0)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Instruction {
    /// `(set! var(.0) var(.1))`
    Variable(VarId, VarId),
    /// `(set! var(.0) global(.1))`
    Global(VarId, usize),
    /// `(set! var(.0) <constant>)`
    Constant(VarId, Value),
    /// `(set! var(.0) (call var(.1) (var(.2)...)))`
    Call(VarId, VarId, Vec<VarId>),
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Instruction::Variable(var, id) => write!(f, "(set! {} {})", var, id),
            Instruction::Global(var, id) => write!(f, "(set! {} global{})", var, id),
            Instruction::Constant(var, ref value) => write!(f, "(set! {} {})", var, value),
            Instruction::Call(var, id, ref ids) => {
                write!(f, "(set! {} (call {} (", var, id)?;
                let mut first = true;
                for id in ids {
                    if !first {
                        write!(f, " ")?;
                    }
                    first = false;
                    write!(f, "{}", id)?;
                }
                write!(f, "))")
            },
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Value {
    Integer(i64),
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Value::Integer(i) => write!(f, "{}", i),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Terminator {
    /// `(jump bb(.0) var(.1))`
    Jump(usize, VarId),
    /// `(return var(.0))`
    Return(VarId),
    /// `(cond var(.0) bb(.1) bb(.2))`
    Cond(VarId, usize, usize)
}

impl fmt::Display for Terminator {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Terminator::Jump(i, v) => write!(f, "(jump bb{} var{})", i, v.0),
            Terminator::Return(i) => write!(f, "(return var{})", i.0),
            Terminator::Cond(v, i, j) => write!(f, "(cond var{} bb{} bb{})", v.0, i, j),
        }
    }
}